---
phase: 03-tech-debt
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - src/game/errors.ts
  - src/effect/errors.ts
  - src/game/wrapMove.ts
autonomous: true
requirements: [DEBT-04]
user_setup: []

must_haves:
  truths:
    - "GameLogicError 和 Effect-TS TaggedError 双轨并存"
    - "错误转换函数存在且可用"
    - "wrapMove 正确处理两种错误类型"
    - "wrapMove 使用 Effect.runSyncExit 执行 Effects（已实现）"
  artifacts:
    - path: "src/game/errors.ts"
      provides: "GameLogicError 定义"
      contains: "class GameLogicError"
    - path: "src/effect/errors.ts"
      provides: "TaggedError 到 GameLogicError 转换"
      contains: "taggedErrorToGameLogicError"
    - path: "src/game/wrapMove.ts"
      provides: "统一错误处理包装器"
      contains: "tryCatchMove"
  key_links:
    - from: "src/game/wrapMove.ts"
      to: "src/effect/errors.ts"
      via: "taggedErrorToGameLogicError"
---

<objective>
统一 GameLogicError 和 Effect-TS TaggedError 错误处理
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-tech-debt/03-CONTEXT.md
@src/game/errors.ts
@src/effect/errors.ts
@src/game/wrapMove.ts

# 根据用户决策:
# - 双轨并存：GameLogicError 和 Effect-TS TaggedError 共存
# - 视情况转换

# 现有实现:
# - src/game/errors.ts: GameLogicError 类
# - src/effect/errors.ts: taggedErrorToGameLogicError 函数
# - src/game/wrapMove.ts: tryCatchMove 包装器，使用 Effect.runSyncExit 执行 Effects
</context>

<tasks>

<task type="auto">
  <name>Task 1: 审查现有错误处理实现</name>
  <files>src/game/errors.ts, src/effect/errors.ts</files>
  <action>
1. 读取 src/game/errors.ts 确认 GameLogicError 实现
2. 读取 src/effect/errors.ts 确认 taggedErrorToGameLogicError 实现
3. 检查转换函数是否覆盖所有 Effect-TS TaggedError 类型
4. 识别可能遗漏的错误类型
  </action>
  <verify>分析现有代码结构，确认转换函数完整</verify>
  <done>现有错误处理实现已审查</done>
</task>

<task type="auto">
  <name>Task 2: 增强错误转换覆盖</name>
  <files>src/effect/errors.ts</files>
  <action>
1. 检查 Effect-TS 服务中定义的所有 TaggedError 类型
2. 确保 taggedErrorToGameLogicError 覆盖所有类型
3. 如有遗漏，添加对应的转换 case
4. 添加错误类型到错误消息的映射
  </action>
  <verify>
1. 运行 `bun run typecheck` 确认无类型错误
2. 确认所有 TaggedError 都有转换处理
  </verify>
  <done>错误转换函数覆盖所有错误类型</done>
</task>

<task type="auto">
  <name>Task 3: 验证 wrapMove 错误处理</name>
  <files>src/game/wrapMove.ts</files>
  <action>
1. 读取 wrapMove.ts 确认 tryCatchMove 实现
2. 验证 GameLogicError 和 TaggedError 都正确处理
3. 确保错误转换正确执行
4. **验证 Effect.runSyncExit 正确执行返回的 Effect**
5. 添加测试验证错误处理流程
  </action>
  <verify>
1. 运行 `bun test` 确认测试通过
2. 确认错误正确传播
  </verify>
  <done>wrapMove 正确统一处理两种错误类型</done>
</task>

</tasks>

<verification>
- [ ] GameLogicError 和 TaggedError 双轨并存
- [ ] 错误转换函数覆盖所有类型
- [ ] wrapMove 正确处理
- [ ] wrapMove 使用 Effect.runSyncExit 自动执行 Effects
- [ ] 测试通过
</verification>

<success_criteria>
GameLogicError 和 Effect-TS TaggedError 错误处理已统一
</success_criteria>

<output>
完成后创建 `.planning/phases/03-tech-debt/03-04-SUMMARY.md`
</output>
