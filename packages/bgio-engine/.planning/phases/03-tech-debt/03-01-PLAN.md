---
phase: 03-tech-debt
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/effect/context/logger.ts
autonomous: true
requirements: []
user_setup: []

must_haves:
  truths:
    - "LoggerService 直接导出，可直接调用"
    - "LoggerService 方法返回 Effect.Effect<void>"
    - "使用 Effect.log (3.19+ API)"
    - "无需 Context 注入，直接调用"
  artifacts:
    - path: "src/effect/context/logger.ts"
      provides: "LoggerService 直接调用接口"
      exports: ["LoggerService", "LogLevel"]
key_links:
  - from: "src/game/moves.ts"
    to: "src/effect/context/logger.ts"
    via: "LoggerService.info(...)"
---

<objective>
创建 LoggerService，为后续替换 console.log 做准备。

**关键约束 (Effect 3.19+):**
- LoggerService 直接导出，无需 Context 注入
- 方法返回 `Effect.Effect<void>`，由 wrapMove 自动执行
- 使用 `Effect.log` (3.19+ API)
- 直接调用: `yield* LoggerService.info("message")`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-tech-debt/03-CONTEXT.md
@src/game/moves.ts
@src/game/phases.ts
@src/game/wrapMove.ts

# LoggerService 直接调用模式
# wrapMove 已使用 Effect.runSyncExit() 自动执行 Effects
</context>

<tasks>

<task type="auto">
  <name>Task 1: 创建 LoggerService</name>
  <files>src/effect/context/logger.ts</files>
  <action>
1. 创建 `src/effect/context/logger.ts` 文件
2. 定义 LogLevel 类型: "debug" | "info" | "warn" | "error"
3. 导出 LoggerService 对象，直接方法调用:
   ```typescript
   export const LoggerService = {
     debug(message: string, ...args: unknown[]): Effect.Effect<void> {
       return Effect.log(`[DEBUG] ${message} ${args.length > 0 ? JSON.stringify(args) : ""}`);
     },
     info(message: string, ...args: unknown[]): Effect.Effect<void> {
       return Effect.log(`[INFO] ${message} ${args.length > 0 ? JSON.stringify(args) : ""}`);
     },
     warn(message: string, ...args: unknown[]): Effect.Effect<void> {
       return Effect.log(`[WARN] ${message} ${args.length > 0 ? JSON.stringify(args) : ""}`);
     },
     error(message: string, ...args: unknown[]): Effect.Effect<void> {
       return Effect.log(`[ERROR] ${message} ${args.length > 0 ? JSON.stringify(args) : ""}`);
     },
   };
   ```
4. 导出 LogLevel 类型和 LoggerService
5. **重要**: 不使用 Effect.logInfo，使用 Effect.log
  </action>
  <verify>运行 `bun run typecheck` 确认无类型错误</verify>
  <done>LoggerService 已创建，可直接调用</done>
</task>

</tasks>

<verification>
- [ ] LoggerService 直接导出
- [ ] LoggerService 方法返回 Effect.Effect<void>
- [ ] 使用 Effect.log 代替 Effect.logInfo
- [ ] 无需 Context 注入
</verification>

<success_criteria>
LoggerService 可直接调用，方法返回 Effect 由 wrapMove 自动执行
</success_criteria>

<output>
完成后创建 `.planning/phases/03-tech-debt/03-01-SUMMARY.md`
</output>
